# 2024년 11월 26일 (화)
> PS할 때 헷갈렸던 배열 초기화

가끔은 이렇게 쉬어가면서...

## 개요
PS 할 때 짧은 코드(빠른 시간)에 배열을 특정 값으로 초기화하기 위하여 `memset()`, `std::fill()` 혹은 파이썬의 `List Comprehension`을 주로 사용한다.

이때 가끔 헷갈리는 것들이 있는데, 예를 들면 2차원 배열을 초기화하기 위해 `std::fill()`이 가능한가? 와 같은 질문이다.

## 공통
사실 가장 마음이 편하고 직관적인 방법은 for문을 돌며 초기화하는 방법이다.
```c
for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
        A[i][j] = INF;
    }
}
```
```py
for i in range(N):
    for j in range(M):
        A[i][j] = INF
```
하지만 이 방법은 단지 배열을 초기화하는 행위에 상대적으로 긴 코드를 작성해야 한다.

## C
C언어에서 배열을 초기화하는 방법은 `memset`밖에 없다.

사실 `memset`은 배열을 초기화하기 위해 존재한다기보단, C언어에 걸맞게, 특정 메모리 주소에 특정 값을 쓰기 위해 존재하는 함수이다.

하지만, 배열의 메모리는 한 묶음(연달아서)으로 할당되어 있으므로, `memset`을 사용하여 초기화할 수 있다.

```c
// 원형
void* memset(void* ptr, int value, size_t num);

// 예시
memset(A, 0, sizeof(A));
```

여기서 주의해야 하는 점은 애초 목적이 배열의 초기화가 아니다 보니, 1바이트가 넘는 값으로 초기화할 수 없다.

즉, 0 이외의 값을 할당하면 의도대로 할당되지 않는다.

예를 들어, 아래와 같이 int 형 배열 `{15, 8}`의 메모리가 할당되어 있다.
|주소|값|
|---|---|
|0x0014|0F|
|0x0015|00|
|0x0016|00|
|0x0017|00|
|0x0018|08|
|0x0019|00|
|0x001A|00|
|0x001B|00|

여기서 `memset(A, 1, sizeof(A))`을 하면 어떤 일이 일어날까?
메모리를 모두 01로 채우게 될 것이다.
그럼 `A = {01010101(2), 01010101(2)}`가 되어 우리가 원하는 `{1, 1}`이 아닌 `{85, 85}`가 나오게 된다.

## C++
그나마 다행인게, c++의 std에서는 배열을 초기화하기 위한 함수를 만들어뒀다.

그것은 바로 `std::fill`<i>(앞으로 std::는 생략)</i>이다.

```cpp
// 원형
template <class ForwardIterator, class T>
  void fill (ForwardIterator first, ForwardIterator last, const T& val);

// 예시
fill(A, A + N, 0);
```

c언어와의 차이점이라면, template에서 마지막 val의 클래스를 추론하여, 그 크기만큼 계산하여 배열을 채워준다는 점이다.

즉, 위와 같은 상황에서 `fill(A, A + N, 2e9)`을 하게 된다면 우리의 의도와 같이 아래처럼 메모리가 할당된다.
|주소|값|
|---|---|
|0x0014|EE|
|0x0015|6B|
|0x0016|28|
|0x0017|00|
|0x0018|EE|
|0x0019|6B|
|0x001A|28|
|0x001B|00|

### fill vs fill_n
CLion을 사용하다 보면, 벡터의 초기화와 달리 배열을 초기화할 땐 `fill_n`을 권장하고 있다.

```cpp
// 원형
template< class OutputIt, class Size, class T >
OutputIt fill_n( OutputIt first, Size count, const T& value );

// 예시
fill_n(A, N, 0);
```

이는 end 주소 대신 그 길이만 넣어주면 된다.

## Python
내가 주로 PS를 할 땐, C/C++을 사용하여 파이썬 문법 상대적으로 덜 익숙하다.

그래서 `[0] * N`과 `[0 for _ in range(N)]`의 차이를 잘 몰랐는데, 이에 대해 정리해보자.

전자의 방법은 문자열 반복('Hi' * 3)을 하는 것과 같은 맥락으로, 같은 레퍼런스를 참조한 값을 복사한다.

즉, `A = [' '] * N`을 수행하였다면, `id(A[0]) == id(A[1]) == id(A[N-1])`가 성립한다.

이 말은, `A[0]`의 값을 수정하면 `A[1]`의 값 또한 같이 수정된다는 점이다.

사실 나는 크게 와닿지 않았던 게, 주로 PS 할 때, 불변인 int를 배열로 사용하다 보니 위의 상황을 겪지 못했다.

하지만 이게 2차원 배열로 늘어난다면 문제가 발생하는데, `[0] * N`을 하여 값을 수정 및 사용하는 건 괜찮지만, `[[0] * N] * M`을 할 경우에 2차원 배열 안의 1차원 배열 자체는 가변이기 때문에, `A[0][0]`를 수정한다면 `A[0][1]`도 수정된다.

사실 나의 경우는 뭔가... 반대되는 경우지만 `[0 for _ in range(N)]`이 조금 더 직관적인 것 같아 이 방식에 적응되었다.